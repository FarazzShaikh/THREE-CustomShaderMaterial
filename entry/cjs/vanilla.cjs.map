{"version":3,"file":"vanilla.cjs","sources":["../../../src/defaults.ts","../../../src/maps/keywordMap.ts","../../../src/maps/availabilityMap.ts","../../../src/maps/patchMap.ts","../../../src/maps/requiredPropsMap.ts","../../../src/sdbm.js","../../../src/utils.ts","../../../src/index.ts"],"sourcesContent":["export const defaultCsmDefinitions = /* glsl */ `\r\n    \r\n#ifdef IS_VERTEX\r\n    vec3 csm_Position;\r\n    vec4 csm_PositionRaw;\r\n    vec3 csm_Normal;\r\n\r\n    // csm_PointSize\r\n    #ifdef IS_POINTSMATERIAL\r\n        float csm_PointSize;\r\n    #endif\r\n#else\r\n    vec4 csm_DiffuseColor;\r\n    vec4 csm_FragColor;\r\n    float csm_FragColorInfluence;\r\n\r\n    // csm_Emissive, csm_Roughness, csm_Metalness\r\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL\r\n        vec3 csm_Emissive;\r\n        float csm_Roughness;\r\n        float csm_Metalness;\r\n        float csm_Iridescence;\r\n        \r\n        #if defined IS_MESHPHYSICALMATERIAL\r\n            float csm_Clearcoat;\r\n            float csm_ClearcoatRoughness;\r\n            vec3 csm_ClearcoatNormal;\r\n            float csm_Transmission;\r\n            float csm_Thickness;\r\n        #endif\r\n    #endif\r\n\r\n    // csm_AO\r\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHBASICMATERIAL || defined IS_MESHLAMBERTMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHTOONMATERIAL\r\n        float csm_AO;\r\n    #endif\r\n\r\n    // csm_Bump\r\n    #if defined IS_MESHLAMBERTMATERIAL || defined IS_MESHMATCAPMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHSTANDARDMATERIAL || defined IS_MESHTOONMATERIAL || defined IS_SHADOWMATERIAL \r\n        vec3 csm_Bump;\r\n    #endif\r\n\r\n    float csm_DepthAlpha;\r\n#endif\r\n`;\r\n\r\nexport const defaultCsmMainDefinitions = /* glsl */ `\r\n\r\n#ifdef IS_VERTEX\r\n    // csm_Position & csm_PositionRaw\r\n    #ifdef IS_UNKNOWN\r\n        csm_Position = vec3(0.0);\r\n        csm_PositionRaw = vec4(0.0);\r\n        csm_Normal = vec3(0.0);\r\n    #else\r\n        csm_Position = position;\r\n        csm_PositionRaw = projectionMatrix * modelViewMatrix * vec4(position, 1.);\r\n        csm_Normal = normal;\r\n    #endif\r\n\r\n    // csm_PointSize\r\n    #ifdef IS_POINTSMATERIAL\r\n        csm_PointSize = size;\r\n    #endif\r\n#else\r\n    csm_FragColorInfluence = 0.0;\r\n\r\n    // csm_DiffuseColor & csm_FragColor\r\n    #if defined IS_UNKNOWN || defined IS_SHADERMATERIAL || defined IS_MESHDEPTHMATERIAL || defined IS_MESHDISTANCEMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_SHADOWMATERIAL\r\n        csm_DiffuseColor = vec4(1.0, 0.0, 1.0, 1.0);\r\n        csm_FragColor = vec4(1.0, 0.0, 1.0, 1.0);\r\n    #else\r\n        #ifdef USE_MAP\r\n            vec4 _csm_sampledDiffuseColor = texture2D(map, vMapUv);\r\n\r\n            #ifdef DECODE_VIDEO_TEXTURE\r\n            // inline sRGB decode (TODO: Remove this code when https://crbug.com/1256340 is solved)\r\n            _csm_sampledDiffuseColor = vec4(mix(pow(_csm_sampledDiffuseColor.rgb * 0.9478672986 + vec3(0.0521327014), vec3(2.4)), _csm_sampledDiffuseColor.rgb * 0.0773993808, vec3(lessThanEqual(_csm_sampledDiffuseColor.rgb, vec3(0.04045)))), _csm_sampledDiffuseColor.w);\r\n            #endif\r\n\r\n            csm_DiffuseColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;\r\n            csm_FragColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;\r\n        #else\r\n            csm_DiffuseColor = vec4(diffuse, opacity);\r\n            csm_FragColor = vec4(diffuse, opacity);\r\n        #endif\r\n    #endif\r\n\r\n    // csm_Emissive, csm_Roughness, csm_Metalness\r\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL\r\n        csm_Emissive = emissive;\r\n        csm_Roughness = roughness;\r\n        csm_Metalness = metalness;\r\n\r\n        #ifdef USE_IRIDESCENCE\r\n            csm_Iridescence = iridescence;\r\n        #else\r\n            csm_Iridescence = 0.0;\r\n        #endif\r\n\r\n        #if defined IS_MESHPHYSICALMATERIAL\r\n            #ifdef USE_CLEARCOAT\r\n                csm_Clearcoat = clearcoat;\r\n                csm_ClearcoatRoughness = clearcoatRoughness;\r\n            #else\r\n                csm_Clearcoat = 0.0;\r\n                csm_ClearcoatRoughness = 0.0;\r\n            #endif\r\n\r\n            #ifdef USE_TRANSMISSION\r\n                csm_Transmission = transmission;\r\n                csm_Thickness = thickness;\r\n            #else\r\n                csm_Transmission = 0.0;\r\n                csm_Thickness = 0.0;\r\n            #endif\r\n        #endif\r\n    #endif\r\n\r\n    // csm_AO\r\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHBASICMATERIAL || defined IS_MESHLAMBERTMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHTOONMATERIAL\r\n        csm_AO = 0.0;\r\n    #endif\r\n\r\n    // csm_Bump\r\n    #if defined IS_MESHLAMBERTMATERIAL || defined IS_MESHMATCAPMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHSTANDARDMATERIAL || defined IS_MESHTOONMATERIAL || defined IS_SHADOWMATERIAL \r\n        csm_Bump = vec3(0.0);\r\n    #endif\r\n\r\n    csm_DepthAlpha = 1.0;\r\n#endif\r\n`;\r\n\r\nexport const defaultVertDefinitions = /* glsl */ `\r\n    varying mat4 csm_internal_vModelViewMatrix;\r\n`;\r\n\r\nexport const defaultVertMain = /* glsl */ `\r\n    csm_internal_vModelViewMatrix = modelViewMatrix;\r\n`;\r\n\r\nexport const defaultFragDefinitions = /* glsl */ `\r\n    varying mat4 csm_internal_vModelViewMatrix;\r\n`;\r\n\r\nexport const defaultFragMain = /* glsl */ `\r\n    \r\n`;\r\n","export const keywordMap = {\r\n  // PBR\r\n  diffuse: \"csm_DiffuseColor\", // Color + alpha\r\n  normal: \"csm_Normal\", // Normal\r\n  roughness: \"csm_Roughness\", // Roughness\r\n  metalness: \"csm_Metalness\", // Metalness\r\n  emissive: \"csm_Emissive\", // Emissive\r\n  ao: \"csm_AO\", // AO\r\n  bump: \"csm_Bump\", // Bump\r\n  clearcoat: \"csm_Clearcoat\", // Clearcoat factor\r\n  clearcoatRoughness: \"csm_ClearcoatRoughness\", // Clearcoat roughness\r\n  clearcoatNormal: \"csm_ClearcoatNormal\", // Clearcoat normals\r\n  transmission: \"csm_Transmission\", // Transmission\r\n  thickness: \"csm_Thickness\", // Thickness\r\n  iridescence: \"csm_Iridescence\", // Iridescence\r\n\r\n  // Extras\r\n  pointSize: \"csm_PointSize\",\r\n  fragColor: \"csm_FragColor\",\r\n  depthAlpha: \"csm_DepthAlpha\", // Depth\r\n  fragColorInfluence: \"csm_FragColorInfluence\", // Unlit factor\r\n\r\n  // Vert\r\n  position: \"csm_Position\",\r\n  positionRaw: \"csm_PositionRaw\",\r\n};\r\n","import { keywordMap } from \"./keywordMap\";\r\n\r\n// Map of CSM keywords to the materials they are available in\r\n// Some keywords are only available in certain materials\r\nexport const availabilityMap = {\r\n  [`${keywordMap.position}`]: \"*\",\r\n  [`${keywordMap.positionRaw}`]: \"*\",\r\n  [`${keywordMap.normal}`]: \"*\",\r\n  [`${keywordMap.depthAlpha}`]: \"*\",\r\n  [`${keywordMap.pointSize}`]: [\"PointsMaterial\"],\r\n\r\n  [`${keywordMap.diffuse}`]: \"*\",\r\n  [`${keywordMap.fragColor}`]: \"*\",\r\n  [`${keywordMap.fragColorInfluence}`]: [\"*\"],\r\n  [`${keywordMap.emissive}`]: [\"MeshStandardMaterial\", \"MeshPhysicalMaterial\"],\r\n  [`${keywordMap.roughness}`]: [\"MeshStandardMaterial\", \"MeshPhysicalMaterial\"],\r\n  [`${keywordMap.metalness}`]: [\"MeshStandardMaterial\", \"MeshPhysicalMaterial\"],\r\n  [`${keywordMap.iridescence}`]: [\r\n    \"MeshStandardMaterial\",\r\n    \"MeshPhysicalMaterial\",\r\n  ],\r\n  [`${keywordMap.ao}`]: [\r\n    \"MeshStandardMaterial\",\r\n    \"MeshPhysicalMaterial\",\r\n    \"MeshBasicMaterial\",\r\n    \"MeshLambertMaterial\",\r\n    \"MeshPhongMaterial\",\r\n    \"MeshToonMaterial\",\r\n  ],\r\n  [`${keywordMap.bump}`]: [\r\n    \"MeshLambertMaterial\",\r\n    \"MeshMatcapMaterial\",\r\n    \"MeshNormalMaterial\",\r\n    \"MeshPhongMaterial\",\r\n    \"MeshPhysicalMaterial\",\r\n    \"MeshStandardMaterial\",\r\n    \"MeshToonMaterial\",\r\n    \"ShadowMaterial\",\r\n  ],\r\n  [`${keywordMap.clearcoat}`]: [\"MeshPhysicalMaterial\"],\r\n  [`${keywordMap.clearcoatRoughness}`]: [\"MeshPhysicalMaterial\"],\r\n  [`${keywordMap.clearcoatNormal}`]: [\"MeshPhysicalMaterial\"],\r\n  [`${keywordMap.transmission}`]: [\"MeshPhysicalMaterial\"],\r\n  [`${keywordMap.thickness}`]: [\"MeshPhysicalMaterial\"],\r\n};\r\n","import * as THREE from \"three\";\r\nimport { CSMPatchMap } from \"../types\";\r\nimport { keywordMap } from \"./keywordMap\";\r\n\r\n// Map of CSM keywords to their substitutions\r\nexport const defaultPatchMap: CSMPatchMap = {\r\n  // VERT\r\n  \"*\": {\r\n    \"#include <lights_physical_fragment>\":\r\n      THREE.ShaderChunk.lights_physical_fragment,\r\n    \"#include <transmission_fragment>\": THREE.ShaderChunk.transmission_fragment,\r\n  },\r\n  [`${keywordMap.normal}`]: {\r\n    \"#include <beginnormal_vertex>\": `\r\n    vec3 objectNormal = ${keywordMap.normal};\r\n    #ifdef USE_TANGENT\r\n\t    vec3 objectTangent = vec3( tangent.xyz );\r\n    #endif\r\n    `,\r\n  },\r\n  [`${keywordMap.position}`]: {\r\n    \"#include <begin_vertex>\": `\r\n    vec3 transformed = ${keywordMap.position};\r\n  `,\r\n  },\r\n  [`${keywordMap.positionRaw}`]: {\r\n    \"#include <begin_vertex>\": `\r\n    vec4 csm_internal_positionUnprojected = ${keywordMap.positionRaw};\r\n    mat4x4 csm_internal_unprojectMatrix = projectionMatrix * modelViewMatrix;\r\n    #ifdef USE_INSTANCING\r\n      csm_internal_unprojectMatrix = csm_internal_unprojectMatrix * instanceMatrix;\r\n    #endif\r\n    csm_internal_positionUnprojected = inverse(csm_internal_unprojectMatrix) * csm_internal_positionUnprojected;\r\n    vec3 transformed = csm_internal_positionUnprojected.xyz;\r\n  `,\r\n  },\r\n  [`${keywordMap.pointSize}`]: {\r\n    \"gl_PointSize = size;\": `\r\n    gl_PointSize = ${keywordMap.pointSize};\r\n    `,\r\n  },\r\n\r\n  // FRAG\r\n\r\n  [`${keywordMap.diffuse}`]: {\r\n    \"#include <color_fragment>\": `\r\n    #include <color_fragment>\r\n    diffuseColor = ${keywordMap.diffuse};\r\n  `,\r\n  },\r\n  [`${keywordMap.fragColor}`]: {\r\n    \"#include <opaque_fragment>\": `\r\n    #include <opaque_fragment>\r\n    gl_FragColor = mix(gl_FragColor, ${keywordMap.fragColor}, ${keywordMap.fragColorInfluence});\r\n  `,\r\n  },\r\n  [`${keywordMap.emissive}`]: {\r\n    \"vec3 totalEmissiveRadiance = emissive;\": `\r\n    vec3 totalEmissiveRadiance = ${keywordMap.emissive};\r\n    `,\r\n  },\r\n  [`${keywordMap.roughness}`]: {\r\n    \"#include <roughnessmap_fragment>\": `\r\n    #include <roughnessmap_fragment>\r\n    roughnessFactor = ${keywordMap.roughness};\r\n    `,\r\n  },\r\n  [`${keywordMap.metalness}`]: {\r\n    \"#include <metalnessmap_fragment>\": `\r\n    #include <metalnessmap_fragment>\r\n    metalnessFactor = ${keywordMap.metalness};\r\n    `,\r\n  },\r\n  [`${keywordMap.ao}`]: {\r\n    \"#include <aomap_fragment>\": `\r\n    #include <aomap_fragment>\r\n    reflectedLight.indirectDiffuse *= 1. - ${keywordMap.ao};\r\n    `,\r\n  },\r\n  [`${keywordMap.bump}`]: {\r\n    \"#include <normal_fragment_maps>\": `\r\n    #include <normal_fragment_maps>\r\n\r\n    vec3 csm_internal_orthogonal = ${keywordMap.bump} - (dot(${keywordMap.bump}, normal) * normal);\r\n    vec3 csm_internal_projectedbump = mat3(csm_internal_vModelViewMatrix) * csm_internal_orthogonal;\r\n    normal = normalize(normal - csm_internal_projectedbump);\r\n    `,\r\n  },\r\n  [`${keywordMap.depthAlpha}`]: {\r\n    \"gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\": `\r\n      gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity * ${keywordMap.depthAlpha} );\r\n    `,\r\n    \"gl_FragColor = packDepthToRGBA( fragCoordZ );\": `\r\n      if(${keywordMap.depthAlpha} > 0.0) discard;\r\n      gl_FragColor = packDepthToRGBA( dist );\r\n    `,\r\n    \"gl_FragColor = packDepthToRGBA( dist );\": `\r\n      if(${keywordMap.depthAlpha} > 0.0) discard;\r\n      gl_FragColor = packDepthToRGBA( dist );\r\n    `,\r\n  },\r\n  [`${keywordMap.clearcoat}`]: {\r\n    \"material.clearcoat = clearcoat;\": `material.clearcoat = ${keywordMap.clearcoat};`,\r\n  },\r\n  [`${keywordMap.clearcoatRoughness}`]: {\r\n    \"material.clearcoatRoughness = clearcoatRoughness;\": `material.clearcoatRoughness = ${keywordMap.clearcoatRoughness};`,\r\n  },\r\n  [`${keywordMap.clearcoatNormal}`]: {\r\n    \"#include <clearcoat_normal_fragment_begin>\": `\r\n      vec3 csm_coat_internal_orthogonal = csm_ClearcoatNormal - (dot(csm_ClearcoatNormal, nonPerturbedNormal) * nonPerturbedNormal);\r\n      vec3 csm_coat_internal_projectedbump = mat3(csm_internal_vModelViewMatrix) * csm_coat_internal_orthogonal;\r\n      vec3 clearcoatNormal = normalize(nonPerturbedNormal - csm_coat_internal_projectedbump);\r\n    `,\r\n  },\r\n  [`${keywordMap.transmission}`]: {\r\n    \"material.transmission = transmission;\": `\r\n      material.transmission = ${keywordMap.transmission};\r\n    `,\r\n  },\r\n  [`${keywordMap.thickness}`]: {\r\n    \"material.thickness = thickness;\": `\r\n      material.thickness = ${keywordMap.thickness};\r\n    `,\r\n  },\r\n  [`${keywordMap.iridescence}`]: {\r\n    \"material.iridescence = iridescence;\": `\r\n      material.iridescence = ${keywordMap.iridescence};\r\n    `,\r\n  },\r\n};\r\n","import { keywordMap } from \"./keywordMap\";\r\n\r\n/**\r\n * Map of props to their keywords\r\n * this is because Three only injects some defines if certain properties are set in the material options.\r\n *\r\n * For example, \"clearcoat\" must be set for 3js to include the #USE_CLEARCOAT define in the shader.\r\n * and thus for our custom clearcoar variant to work\r\n */\r\nexport const requiredPropsMap = {\r\n  clearcoat: [\r\n    keywordMap.clearcoat,\r\n    keywordMap.clearcoatNormal,\r\n    keywordMap.clearcoatRoughness,\r\n  ],\r\n  transmission: [keywordMap.transmission],\r\n  iridescence: [keywordMap.iridescence],\r\n};\r\n","//https://github.com/sindresorhus/sdbm\r\n\r\nexport default function sdbm(string) {\r\n  let hash = 0;\r\n\r\n  for (let i = 0; i < string.length; i++) {\r\n    hash = string.charCodeAt(i) + (hash << 6) + (hash << 16) - hash;\r\n  }\r\n\r\n  // Convert it to an unsigned 32-bit integer.\r\n  const h = hash >>> 0;\r\n  const str = String(h);\r\n  return str;\r\n}\r\n","import { MaterialConstructor } from \"./types\";\r\n\r\n// Hacky, yikes!\r\nexport function isConstructor<T extends MaterialConstructor>(\r\n  f: T | InstanceType<T>\r\n): f is T {\r\n  try {\r\n    // @ts-ignore\r\n    new f();\r\n  } catch (err) {\r\n    if ((err as any).message.indexOf(\"is not a constructor\") >= 0) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nexport function deepMergeObjects<T extends Record<string, any>>(\r\n  target: T,\r\n  source: T\r\n): T {\r\n  for (const key in source) {\r\n    // @ts-ignore\r\n    if (source[key] instanceof Object)\r\n      Object.assign(source[key], deepMergeObjects(target[key], source[key]));\r\n  }\r\n\r\n  Object.assign(target || {}, source);\r\n  return target;\r\n}\r\n\r\n// Remove all comments in a string\r\n// both block and inline comments\r\nexport function stripComments(str: string) {\r\n  return str.replace(/\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*/g, \"\");\r\n}\r\n\r\nexport function stripNewLines(str: string) {\r\n  return str.replace(/\\n/g, \"\");\r\n}\r\n\r\nexport function stripSpaces(str: string) {\r\n  return str.replace(/\\s/g, \"\");\r\n}\r\n\r\nexport function isEmptyFunction(func: Function) {\r\n  const funcName = func.name;\r\n  return stripSpaces(stripNewLines(func.toString())) === `${funcName}(){}`;\r\n}\r\n","import * as THREE from \"three\";\r\nimport {\r\n  defaultCsmDefinitions,\r\n  defaultCsmMainDefinitions,\r\n  defaultFragDefinitions,\r\n  defaultFragMain,\r\n  defaultVertDefinitions,\r\n  defaultVertMain,\r\n} from \"./defaults\";\r\nimport { availabilityMap, defaultPatchMap } from \"./maps\";\r\nimport { requiredPropsMap } from \"./maps/requiredPropsMap\";\r\nimport hash from \"./sdbm\";\r\nimport * as TYPES from \"./types\";\r\nimport {\r\n  deepMergeObjects,\r\n  isConstructor,\r\n  isEmptyFunction,\r\n  stripComments,\r\n} from \"./utils\";\r\n\r\nexport default class CustomShaderMaterial<\r\n  T extends TYPES.MaterialConstructor = typeof THREE.Material\r\n> extends THREE.Material {\r\n  uniforms: TYPES.Uniform = {};\r\n  vertexShader: string = \"\";\r\n  fragmentShader: string = \"\";\r\n\r\n  constructor({\r\n    baseMaterial,\r\n    vertexShader,\r\n    fragmentShader,\r\n    uniforms,\r\n    patchMap,\r\n    cacheKey,\r\n    ...opts\r\n  }: TYPES.CustomShaderMaterialParameters<T>) {\r\n    if (!baseMaterial) {\r\n      throw new Error(\"CustomShaderMaterial: baseMaterial is required.\");\r\n    }\r\n\r\n    let base: THREE.Material;\r\n    if (isConstructor(baseMaterial)) {\r\n      // If base material is a constructor, instantiate it\r\n      // if opts is empty, replace it with undefined\r\n      const isEmptyOpts = Object.keys(opts).length === 0;\r\n      base = new baseMaterial(isEmptyOpts ? undefined : opts);\r\n    } else {\r\n      // Else, use the already created instance as the base material\r\n      // and copy options onto it\r\n      base = baseMaterial;\r\n      Object.assign(base, opts);\r\n    }\r\n\r\n    // Blacklist some materials that are not supported\r\n    const blackList = [\"ShaderMaterial\", \"RawShaderMaterial\"];\r\n    if (blackList.includes(base.type)) {\r\n      throw new Error(\r\n        `CustomShaderMaterial does not support ${base.type} as a base material.`\r\n      );\r\n    }\r\n\r\n    super();\r\n\r\n    // Return a proxy to the base material with CSM types and methods\r\n    const extendedBase = base as typeof base & TYPES.CSMProxy<T>;\r\n    extendedBase.name = `CustomShaderMaterial<${base.name}>`;\r\n    extendedBase.update = this.update.bind(extendedBase);\r\n    extendedBase.__csm = { prevOnBeforeCompile: base.onBeforeCompile };\r\n\r\n    const prevUniforms = extendedBase.uniforms || {};\r\n    const newUniforms = uniforms || {};\r\n    const mergedUniforms = { ...prevUniforms, ...newUniforms };\r\n\r\n    extendedBase.uniforms = this.uniforms = mergedUniforms;\r\n    extendedBase.vertexShader = this.vertexShader = vertexShader || \"\";\r\n    extendedBase.fragmentShader = this.fragmentShader = fragmentShader || \"\";\r\n\r\n    // Initialize custom shaders\r\n    extendedBase.update({\r\n      fragmentShader: extendedBase.fragmentShader,\r\n      vertexShader: extendedBase.vertexShader,\r\n      uniforms: extendedBase.uniforms,\r\n      patchMap,\r\n      cacheKey,\r\n    });\r\n\r\n    return extendedBase;\r\n  }\r\n\r\n  update({\r\n    fragmentShader: _fs,\r\n    vertexShader: _vs,\r\n    uniforms,\r\n    cacheKey,\r\n    patchMap,\r\n  }: Omit<TYPES.CustomShaderMaterialBaseParameters<T>, \"baseMaterial\">) {\r\n    // Strip comments from shaders, makes it so that commented keywords are not detected\r\n    const vertexShader = stripComments(_vs || \"\");\r\n    const fragmentShader = stripComments(_fs || \"\");\r\n\r\n    // Get typed `this` for the proxy\r\n    const self = this as typeof this & TYPES.CSMProxy<T>;\r\n\r\n    // Replace the shaders if they are provided\r\n    if (uniforms) self.uniforms = uniforms;\r\n    if (_vs) self.vertexShader = _vs;\r\n    if (_fs) self.fragmentShader = _fs;\r\n\r\n    // Some keywords require certain properties to be set for their chunks to be included via #ifdef\r\n    // so we must check if the shaders contain these keywords and set the properties accordingly\r\n    Object.entries(requiredPropsMap).forEach(([prop, matchKeywords]) => {\r\n      for (const keyword in matchKeywords) {\r\n        const matchKeyword = matchKeywords[keyword];\r\n        if (\r\n          (fragmentShader && fragmentShader.includes(matchKeyword)) ||\r\n          (vertexShader && vertexShader.includes(matchKeyword))\r\n        ) {\r\n          // @ts-ignore\r\n          if (!self[prop]) {\r\n            // @ts-ignore\r\n            self[prop] = 1;\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    // Check it the previous onBeforeCompile exists\r\n    const prevOnBeforeCompile = self.__csm.prevOnBeforeCompile;\r\n    const doesHavePreviousBeforeCompile = !isEmptyFunction(prevOnBeforeCompile);\r\n\r\n    // Helper function to extend the shader\r\n    const extendShader = (\r\n      prevShader: string,\r\n      newShader?: string,\r\n      isFrag?: boolean\r\n    ) => {\r\n      let mainBody: string | undefined;\r\n      let beforeMain: string = \"\";\r\n\r\n      // Prepare the main body and beforeMain\r\n      if (newShader) {\r\n        const mainBodyRegex =\r\n          /void\\s+main\\s*\\(\\s*\\)[^{]*{((?:[^{}]+|{(?:[^{}]+|{(?:[^{}]+|{(?:[^{}]+|{[^{}]*})*})*})*})*})/gm;\r\n        const mainBodyMatches = newShader.matchAll(mainBodyRegex);\r\n        mainBody = mainBodyMatches.next().value?.[1];\r\n        if (mainBody) mainBody = mainBody.slice(0, -1);\r\n\r\n        const mainIndex = newShader.indexOf(\"void main() {\");\r\n        beforeMain = newShader.slice(0, mainIndex);\r\n      }\r\n\r\n      // Inject\r\n      if (doesHavePreviousBeforeCompile) {\r\n        prevShader = prevShader.replace(\r\n          \"void main() {\",\r\n          `\r\n          // THREE-CustomShaderMaterial by Faraz Shaikh: https://github.com/FarazzShaikh/THREE-CustomShaderMaterial\r\n  \r\n          ${beforeMain}\r\n          \r\n          void main() {\r\n          `\r\n        );\r\n\r\n        const lastMainEndIndex = prevShader.lastIndexOf(\"//~CSM_MAIN_END\");\r\n\r\n        if (lastMainEndIndex !== -1) {\r\n          const toAppend = `\r\n            ${mainBody ? `${mainBody}` : \"\"}\r\n            //~CSM_MAIN_END\r\n          `;\r\n          prevShader =\r\n            prevShader.slice(0, lastMainEndIndex) +\r\n            toAppend +\r\n            prevShader.slice(lastMainEndIndex);\r\n        }\r\n      } else {\r\n        const regex = /void\\s*main\\s*\\(\\s*\\)\\s*{/gm;\r\n\r\n        prevShader = prevShader.replace(\r\n          regex,\r\n          `\r\n          // THREE-CustomShaderMaterial by Faraz Shaikh: https://github.com/FarazzShaikh/THREE-CustomShaderMaterial\r\n  \r\n          ${isFrag ? defaultFragDefinitions : defaultVertDefinitions}\r\n          ${defaultCsmDefinitions}\r\n  \r\n          ${beforeMain}\r\n          \r\n          void main() {\r\n            ${defaultCsmMainDefinitions}\r\n            ${isFrag ? defaultFragMain : defaultVertMain}\r\n\r\n            ${mainBody ? `${mainBody}` : \"\"}\r\n            //~CSM_MAIN_END\r\n          `\r\n        );\r\n      }\r\n\r\n      return prevShader;\r\n    };\r\n\r\n    // Override onBeforeCompile\r\n    self.onBeforeCompile = (\r\n      shader: THREE.WebGLProgramParametersWithUniforms,\r\n      renderer: THREE.WebGLRenderer\r\n    ) => {\r\n      // Apply previous onBeforeCompile\r\n      prevOnBeforeCompile?.(shader, renderer);\r\n\r\n      const userPatchMap = patchMap || {};\r\n      const mergedPatchMap = deepMergeObjects(defaultPatchMap, userPatchMap);\r\n\r\n      // Append some defines\r\n      const type = self.type;\r\n      const typeDefine = type\r\n        ? `#define IS_${type.toUpperCase()};\\n`\r\n        : `#define IS_UNKNOWN;\\n`;\r\n      shader.vertexShader =\r\n        typeDefine + \"#define IS_VERTEX\\n\" + shader.vertexShader;\r\n      shader.fragmentShader =\r\n        typeDefine + \"#define IS_FRAGMENT\\n\" + shader.fragmentShader;\r\n\r\n      // Check if the keyword is available in the current material type\r\n      for (const keyword in mergedPatchMap) {\r\n        const doesIncludeInVert =\r\n          keyword === \"*\" || (vertexShader && vertexShader.includes(keyword));\r\n        const doesIncludeInFrag =\r\n          keyword === \"*\" ||\r\n          (fragmentShader && fragmentShader.includes(keyword));\r\n\r\n        if (doesIncludeInFrag || doesIncludeInVert) {\r\n          const availableIn = availabilityMap[keyword];\r\n\r\n          if (\r\n            availableIn &&\r\n            availableIn !== \"*\" &&\r\n            (Array.isArray(availableIn)\r\n              ? !availableIn.includes(type)\r\n              : availableIn !== type)\r\n          ) {\r\n            console.error(\r\n              `CustomShaderMaterial: ${keyword} is not available in ${type}. Shader cannot compile.`\r\n            );\r\n            return;\r\n          }\r\n\r\n          const patchMap = mergedPatchMap[keyword];\r\n\r\n          for (const toReplace in patchMap) {\r\n            const replaceWith = patchMap[toReplace];\r\n            if (typeof replaceWith === \"object\") {\r\n              const type = replaceWith.type;\r\n              const value = replaceWith.value;\r\n\r\n              if (type === \"fs\") {\r\n                shader.fragmentShader = shader.fragmentShader.replace(\r\n                  toReplace,\r\n                  value\r\n                );\r\n              } else if (type === \"vs\") {\r\n                shader.vertexShader = shader.vertexShader.replace(\r\n                  toReplace,\r\n                  value\r\n                );\r\n              }\r\n            } else if (replaceWith) {\r\n              shader.vertexShader = shader.vertexShader.replace(\r\n                toReplace,\r\n                replaceWith\r\n              );\r\n              shader.fragmentShader = shader.fragmentShader.replace(\r\n                toReplace,\r\n                replaceWith\r\n              );\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Extend the shaders\r\n      shader.vertexShader = extendShader(\r\n        shader.vertexShader,\r\n        vertexShader,\r\n        false\r\n      );\r\n\r\n      shader.fragmentShader = extendShader(\r\n        shader.fragmentShader,\r\n        fragmentShader,\r\n        true\r\n      );\r\n\r\n      if (uniforms) {\r\n        shader.uniforms = { ...shader.uniforms, ...self.uniforms };\r\n      }\r\n\r\n      self.uniforms = shader.uniforms;\r\n    };\r\n\r\n    const prevCacheKey = self.customProgramCacheKey;\r\n\r\n    self.customProgramCacheKey = () => {\r\n      return (\r\n        (cacheKey?.() || hash((vertexShader || \"\") + (fragmentShader || \"\"))) +\r\n        prevCacheKey?.call(self)\r\n      );\r\n    };\r\n\r\n    self.needsUpdate = true;\r\n  }\r\n}\r\n\r\nexport {\r\n  type CSMPatchMap,\r\n  type CSMProxy,\r\n  type CustomShaderMaterialParameters,\r\n  type MaterialConstructor,\r\n} from \"./types\";\r\n"],"names":["defaultCsmDefinitions","defaultCsmMainDefinitions","defaultVertDefinitions","defaultVertMain","defaultFragDefinitions","defaultFragMain","keywordMap","availabilityMap","defaultPatchMap","THREE","requiredPropsMap","sdbm","string","hash","i","h","isConstructor","f","err","deepMergeObjects","target","source","key","stripComments","str","stripNewLines","stripSpaces","isEmptyFunction","func","funcName","CustomShaderMaterial","baseMaterial","vertexShader","fragmentShader","uniforms","patchMap","cacheKey","opts","base","isEmptyOpts","extendedBase","mergedUniforms","_fs","_vs","self","prop","matchKeywords","keyword","matchKeyword","prevOnBeforeCompile","doesHavePreviousBeforeCompile","extendShader","prevShader","newShader","isFrag","mainBody","beforeMain","mainBodyRegex","_a","mainIndex","lastMainEndIndex","toAppend","regex","shader","renderer","mergedPatchMap","type","typeDefine","doesIncludeInVert","availableIn","toReplace","replaceWith","value","prevCacheKey"],"mappings":"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"}