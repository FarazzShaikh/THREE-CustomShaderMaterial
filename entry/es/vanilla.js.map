{"version":3,"file":"vanilla.js","sources":["../../../src/defaults.ts","../../../src/maps/keywordMap.ts","../../../src/maps/availabilityMap.ts","../../../src/maps/patchMap.ts","../../../src/maps/requiredPropsMap.ts","../../../src/sdbm.js","../../../src/utils.ts","../../../src/index.ts"],"sourcesContent":["export const defaultCsmDefinitions = /* glsl */ `\r\n    \r\n#ifdef IS_VERTEX\r\n    vec3 csm_Position;\r\n    vec4 csm_PositionRaw;\r\n    vec3 csm_Normal;\r\n\r\n    // csm_PointSize\r\n    #ifdef IS_POINTSMATERIAL\r\n        float csm_PointSize;\r\n    #endif\r\n#else\r\n    vec4 csm_DiffuseColor;\r\n    vec4 csm_FragColor;\r\n    float csm_FragColorInfluence;\r\n\r\n    // csm_Emissive, csm_Roughness, csm_Metalness\r\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL\r\n        vec3 csm_Emissive;\r\n        float csm_Roughness;\r\n        float csm_Metalness;\r\n        float csm_Iridescence;\r\n        \r\n        #if defined IS_MESHPHYSICALMATERIAL\r\n            float csm_Clearcoat;\r\n            float csm_ClearcoatRoughness;\r\n            vec3 csm_ClearcoatNormal;\r\n            float csm_Transmission;\r\n            float csm_Thickness;\r\n        #endif\r\n    #endif\r\n\r\n    // csm_AO\r\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHBASICMATERIAL || defined IS_MESHLAMBERTMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHTOONMATERIAL\r\n        float csm_AO;\r\n    #endif\r\n\r\n    // csm_Bump\r\n    #if defined IS_MESHLAMBERTMATERIAL || defined IS_MESHMATCAPMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHSTANDARDMATERIAL || defined IS_MESHTOONMATERIAL || defined IS_SHADOWMATERIAL \r\n        vec3 csm_Bump;\r\n    #endif\r\n\r\n    float csm_DepthAlpha;\r\n#endif\r\n`;\r\n\r\nexport const defaultCsmMainDefinitions = /* glsl */ `\r\n\r\n#ifdef IS_VERTEX\r\n    // csm_Position & csm_PositionRaw\r\n    #ifdef IS_UNKNOWN\r\n        csm_Position = vec3(0.0);\r\n        csm_PositionRaw = vec4(0.0);\r\n        csm_Normal = vec3(0.0);\r\n    #else\r\n        csm_Position = position;\r\n        csm_PositionRaw = projectionMatrix * modelViewMatrix * vec4(position, 1.);\r\n        csm_Normal = normal;\r\n    #endif\r\n\r\n    // csm_PointSize\r\n    #ifdef IS_POINTSMATERIAL\r\n        csm_PointSize = size;\r\n    #endif\r\n#else\r\n    csm_FragColorInfluence = 0.0;\r\n\r\n    // csm_DiffuseColor & csm_FragColor\r\n    #if defined IS_UNKNOWN || defined IS_SHADERMATERIAL || defined IS_MESHDEPTHMATERIAL || defined IS_MESHDISTANCEMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_SHADOWMATERIAL\r\n        csm_DiffuseColor = vec4(1.0, 0.0, 1.0, 1.0);\r\n        csm_FragColor = vec4(1.0, 0.0, 1.0, 1.0);\r\n    #else\r\n        #ifdef USE_MAP\r\n            vec4 _csm_sampledDiffuseColor = texture2D(map, vMapUv);\r\n\r\n            #ifdef DECODE_VIDEO_TEXTURE\r\n            // inline sRGB decode (TODO: Remove this code when https://crbug.com/1256340 is solved)\r\n            _csm_sampledDiffuseColor = vec4(mix(pow(_csm_sampledDiffuseColor.rgb * 0.9478672986 + vec3(0.0521327014), vec3(2.4)), _csm_sampledDiffuseColor.rgb * 0.0773993808, vec3(lessThanEqual(_csm_sampledDiffuseColor.rgb, vec3(0.04045)))), _csm_sampledDiffuseColor.w);\r\n            #endif\r\n\r\n            csm_DiffuseColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;\r\n            csm_FragColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;\r\n        #else\r\n            csm_DiffuseColor = vec4(diffuse, opacity);\r\n            csm_FragColor = vec4(diffuse, opacity);\r\n        #endif\r\n    #endif\r\n\r\n    // csm_Emissive, csm_Roughness, csm_Metalness\r\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL\r\n        csm_Emissive = emissive;\r\n        csm_Roughness = roughness;\r\n        csm_Metalness = metalness;\r\n\r\n        #ifdef USE_IRIDESCENCE\r\n            csm_Iridescence = iridescence;\r\n        #else\r\n            csm_Iridescence = 0.0;\r\n        #endif\r\n\r\n        #if defined IS_MESHPHYSICALMATERIAL\r\n            #ifdef USE_CLEARCOAT\r\n                csm_Clearcoat = clearcoat;\r\n                csm_ClearcoatRoughness = clearcoatRoughness;\r\n            #else\r\n                csm_Clearcoat = 0.0;\r\n                csm_ClearcoatRoughness = 0.0;\r\n            #endif\r\n\r\n            #ifdef USE_TRANSMISSION\r\n                csm_Transmission = transmission;\r\n                csm_Thickness = thickness;\r\n            #else\r\n                csm_Transmission = 0.0;\r\n                csm_Thickness = 0.0;\r\n            #endif\r\n        #endif\r\n    #endif\r\n\r\n    // csm_AO\r\n    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHBASICMATERIAL || defined IS_MESHLAMBERTMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHTOONMATERIAL\r\n        csm_AO = 0.0;\r\n    #endif\r\n\r\n    // csm_Bump\r\n    #if defined IS_MESHLAMBERTMATERIAL || defined IS_MESHMATCAPMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHSTANDARDMATERIAL || defined IS_MESHTOONMATERIAL || defined IS_SHADOWMATERIAL \r\n        csm_Bump = vec3(0.0);\r\n    #endif\r\n\r\n    csm_DepthAlpha = 1.0;\r\n#endif\r\n`;\r\n\r\nexport const defaultVertDefinitions = /* glsl */ `\r\n    varying mat4 csm_internal_vModelViewMatrix;\r\n`;\r\n\r\nexport const defaultVertMain = /* glsl */ `\r\n    csm_internal_vModelViewMatrix = modelViewMatrix;\r\n`;\r\n\r\nexport const defaultFragDefinitions = /* glsl */ `\r\n    varying mat4 csm_internal_vModelViewMatrix;\r\n`;\r\n\r\nexport const defaultFragMain = /* glsl */ `\r\n    \r\n`;\r\n","export const keywordMap = {\r\n  // PBR\r\n  diffuse: \"csm_DiffuseColor\", // Color + alpha\r\n  normal: \"csm_Normal\", // Normal\r\n  roughness: \"csm_Roughness\", // Roughness\r\n  metalness: \"csm_Metalness\", // Metalness\r\n  emissive: \"csm_Emissive\", // Emissive\r\n  ao: \"csm_AO\", // AO\r\n  bump: \"csm_Bump\", // Bump\r\n  clearcoat: \"csm_Clearcoat\", // Clearcoat factor\r\n  clearcoatRoughness: \"csm_ClearcoatRoughness\", // Clearcoat roughness\r\n  clearcoatNormal: \"csm_ClearcoatNormal\", // Clearcoat normals\r\n  transmission: \"csm_Transmission\", // Transmission\r\n  thickness: \"csm_Thickness\", // Thickness\r\n  iridescence: \"csm_Iridescence\", // Iridescence\r\n\r\n  // Extras\r\n  pointSize: \"csm_PointSize\",\r\n  fragColor: \"csm_FragColor\",\r\n  depthAlpha: \"csm_DepthAlpha\", // Depth\r\n  fragColorInfluence: \"csm_FragColorInfluence\", // Unlit factor\r\n\r\n  // Vert\r\n  position: \"csm_Position\",\r\n  positionRaw: \"csm_PositionRaw\",\r\n};\r\n","import { keywordMap } from \"./keywordMap\";\r\n\r\n// Map of CSM keywords to the materials they are available in\r\n// Some keywords are only available in certain materials\r\nexport const availabilityMap = {\r\n  [`${keywordMap.position}`]: \"*\",\r\n  [`${keywordMap.positionRaw}`]: \"*\",\r\n  [`${keywordMap.normal}`]: \"*\",\r\n  [`${keywordMap.depthAlpha}`]: \"*\",\r\n  [`${keywordMap.pointSize}`]: [\"PointsMaterial\"],\r\n\r\n  [`${keywordMap.diffuse}`]: \"*\",\r\n  [`${keywordMap.fragColor}`]: \"*\",\r\n  [`${keywordMap.fragColorInfluence}`]: [\"*\"],\r\n  [`${keywordMap.emissive}`]: [\"MeshStandardMaterial\", \"MeshPhysicalMaterial\"],\r\n  [`${keywordMap.roughness}`]: [\"MeshStandardMaterial\", \"MeshPhysicalMaterial\"],\r\n  [`${keywordMap.metalness}`]: [\"MeshStandardMaterial\", \"MeshPhysicalMaterial\"],\r\n  [`${keywordMap.iridescence}`]: [\r\n    \"MeshStandardMaterial\",\r\n    \"MeshPhysicalMaterial\",\r\n  ],\r\n  [`${keywordMap.ao}`]: [\r\n    \"MeshStandardMaterial\",\r\n    \"MeshPhysicalMaterial\",\r\n    \"MeshBasicMaterial\",\r\n    \"MeshLambertMaterial\",\r\n    \"MeshPhongMaterial\",\r\n    \"MeshToonMaterial\",\r\n  ],\r\n  [`${keywordMap.bump}`]: [\r\n    \"MeshLambertMaterial\",\r\n    \"MeshMatcapMaterial\",\r\n    \"MeshNormalMaterial\",\r\n    \"MeshPhongMaterial\",\r\n    \"MeshPhysicalMaterial\",\r\n    \"MeshStandardMaterial\",\r\n    \"MeshToonMaterial\",\r\n    \"ShadowMaterial\",\r\n  ],\r\n  [`${keywordMap.clearcoat}`]: [\"MeshPhysicalMaterial\"],\r\n  [`${keywordMap.clearcoatRoughness}`]: [\"MeshPhysicalMaterial\"],\r\n  [`${keywordMap.clearcoatNormal}`]: [\"MeshPhysicalMaterial\"],\r\n  [`${keywordMap.transmission}`]: [\"MeshPhysicalMaterial\"],\r\n  [`${keywordMap.thickness}`]: [\"MeshPhysicalMaterial\"],\r\n};\r\n","import * as THREE from \"three\";\r\nimport { CSMPatchMap } from \"../types\";\r\nimport { keywordMap } from \"./keywordMap\";\r\n\r\n// Map of CSM keywords to their substitutions\r\nexport const defaultPatchMap: CSMPatchMap = {\r\n  // VERT\r\n  \"*\": {\r\n    \"#include <lights_physical_fragment>\":\r\n      THREE.ShaderChunk.lights_physical_fragment,\r\n    \"#include <transmission_fragment>\": THREE.ShaderChunk.transmission_fragment,\r\n  },\r\n  [`${keywordMap.normal}`]: {\r\n    \"#include <beginnormal_vertex>\": `\r\n    vec3 objectNormal = ${keywordMap.normal};\r\n    #ifdef USE_TANGENT\r\n\t    vec3 objectTangent = vec3( tangent.xyz );\r\n    #endif\r\n    `,\r\n  },\r\n  [`${keywordMap.position}`]: {\r\n    \"#include <begin_vertex>\": `\r\n    vec3 transformed = ${keywordMap.position};\r\n  `,\r\n  },\r\n  [`${keywordMap.positionRaw}`]: {\r\n    \"#include <begin_vertex>\": `\r\n    vec4 csm_internal_positionUnprojected = ${keywordMap.positionRaw};\r\n    mat4x4 csm_internal_unprojectMatrix = projectionMatrix * modelViewMatrix;\r\n    #ifdef USE_INSTANCING\r\n      csm_internal_unprojectMatrix = csm_internal_unprojectMatrix * instanceMatrix;\r\n    #endif\r\n    csm_internal_positionUnprojected = inverse(csm_internal_unprojectMatrix) * csm_internal_positionUnprojected;\r\n    vec3 transformed = csm_internal_positionUnprojected.xyz;\r\n  `,\r\n  },\r\n  [`${keywordMap.pointSize}`]: {\r\n    \"gl_PointSize = size;\": `\r\n    gl_PointSize = ${keywordMap.pointSize};\r\n    `,\r\n  },\r\n\r\n  // FRAG\r\n\r\n  [`${keywordMap.diffuse}`]: {\r\n    \"#include <color_fragment>\": `\r\n    #include <color_fragment>\r\n    diffuseColor = ${keywordMap.diffuse};\r\n  `,\r\n  },\r\n  [`${keywordMap.fragColor}`]: {\r\n    \"#include <opaque_fragment>\": `\r\n    #include <opaque_fragment>\r\n    gl_FragColor = mix(gl_FragColor, ${keywordMap.fragColor}, ${keywordMap.fragColorInfluence});\r\n  `,\r\n  },\r\n  [`${keywordMap.emissive}`]: {\r\n    \"vec3 totalEmissiveRadiance = emissive;\": `\r\n    vec3 totalEmissiveRadiance = ${keywordMap.emissive};\r\n    `,\r\n  },\r\n  [`${keywordMap.roughness}`]: {\r\n    \"#include <roughnessmap_fragment>\": `\r\n    #include <roughnessmap_fragment>\r\n    roughnessFactor = ${keywordMap.roughness};\r\n    `,\r\n  },\r\n  [`${keywordMap.metalness}`]: {\r\n    \"#include <metalnessmap_fragment>\": `\r\n    #include <metalnessmap_fragment>\r\n    metalnessFactor = ${keywordMap.metalness};\r\n    `,\r\n  },\r\n  [`${keywordMap.ao}`]: {\r\n    \"#include <aomap_fragment>\": `\r\n    #include <aomap_fragment>\r\n    reflectedLight.indirectDiffuse *= 1. - ${keywordMap.ao};\r\n    `,\r\n  },\r\n  [`${keywordMap.bump}`]: {\r\n    \"#include <normal_fragment_maps>\": `\r\n    #include <normal_fragment_maps>\r\n\r\n    vec3 csm_internal_orthogonal = ${keywordMap.bump} - (dot(${keywordMap.bump}, normal) * normal);\r\n    vec3 csm_internal_projectedbump = mat3(csm_internal_vModelViewMatrix) * csm_internal_orthogonal;\r\n    normal = normalize(normal - csm_internal_projectedbump);\r\n    `,\r\n  },\r\n  [`${keywordMap.depthAlpha}`]: {\r\n    \"gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\": `\r\n      gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity * ${keywordMap.depthAlpha} );\r\n    `,\r\n    \"gl_FragColor = packDepthToRGBA( fragCoordZ );\": `\r\n      if(${keywordMap.depthAlpha} > 0.0) discard;\r\n      gl_FragColor = packDepthToRGBA( dist );\r\n    `,\r\n    \"gl_FragColor = packDepthToRGBA( dist );\": `\r\n      if(${keywordMap.depthAlpha} > 0.0) discard;\r\n      gl_FragColor = packDepthToRGBA( dist );\r\n    `,\r\n  },\r\n  [`${keywordMap.clearcoat}`]: {\r\n    \"material.clearcoat = clearcoat;\": `material.clearcoat = ${keywordMap.clearcoat};`,\r\n  },\r\n  [`${keywordMap.clearcoatRoughness}`]: {\r\n    \"material.clearcoatRoughness = clearcoatRoughness;\": `material.clearcoatRoughness = ${keywordMap.clearcoatRoughness};`,\r\n  },\r\n  [`${keywordMap.clearcoatNormal}`]: {\r\n    \"#include <clearcoat_normal_fragment_begin>\": `\r\n      vec3 csm_coat_internal_orthogonal = csm_ClearcoatNormal - (dot(csm_ClearcoatNormal, nonPerturbedNormal) * nonPerturbedNormal);\r\n      vec3 csm_coat_internal_projectedbump = mat3(csm_internal_vModelViewMatrix) * csm_coat_internal_orthogonal;\r\n      vec3 clearcoatNormal = normalize(nonPerturbedNormal - csm_coat_internal_projectedbump);\r\n    `,\r\n  },\r\n  [`${keywordMap.transmission}`]: {\r\n    \"material.transmission = transmission;\": `\r\n      material.transmission = ${keywordMap.transmission};\r\n    `,\r\n  },\r\n  [`${keywordMap.thickness}`]: {\r\n    \"material.thickness = thickness;\": `\r\n      material.thickness = ${keywordMap.thickness};\r\n    `,\r\n  },\r\n  [`${keywordMap.iridescence}`]: {\r\n    \"material.iridescence = iridescence;\": `\r\n      material.iridescence = ${keywordMap.iridescence};\r\n    `,\r\n  },\r\n};\r\n","import { keywordMap } from \"./keywordMap\";\r\n\r\n/**\r\n * Map of props to their keywords\r\n * this is because Three only injects some defines if certain properties are set in the material options.\r\n *\r\n * For example, \"clearcoat\" must be set for 3js to include the #USE_CLEARCOAT define in the shader.\r\n * and thus for our custom clearcoar variant to work\r\n */\r\nexport const requiredPropsMap = {\r\n  clearcoat: [\r\n    keywordMap.clearcoat,\r\n    keywordMap.clearcoatNormal,\r\n    keywordMap.clearcoatRoughness,\r\n  ],\r\n  transmission: [keywordMap.transmission],\r\n  iridescence: [keywordMap.iridescence],\r\n};\r\n","//https://github.com/sindresorhus/sdbm\r\n\r\nexport default function sdbm(string) {\r\n  let hash = 0;\r\n\r\n  for (let i = 0; i < string.length; i++) {\r\n    hash = string.charCodeAt(i) + (hash << 6) + (hash << 16) - hash;\r\n  }\r\n\r\n  // Convert it to an unsigned 32-bit integer.\r\n  const h = hash >>> 0;\r\n  const str = String(h);\r\n  return str;\r\n}\r\n","import { MaterialConstructor } from \"./types\";\r\n\r\n// Hacky, yikes!\r\nexport function isConstructor<T extends MaterialConstructor>(\r\n  f: T | InstanceType<T>\r\n): f is T {\r\n  try {\r\n    // @ts-ignore\r\n    new f();\r\n  } catch (err) {\r\n    if ((err as any).message.indexOf(\"is not a constructor\") >= 0) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nexport function deepMergeObjects<T extends Record<string, any>>(\r\n  target: T,\r\n  source: T\r\n): T {\r\n  for (const key in source) {\r\n    // @ts-ignore\r\n    if (source[key] instanceof Object)\r\n      Object.assign(source[key], deepMergeObjects(target[key], source[key]));\r\n  }\r\n\r\n  Object.assign(target || {}, source);\r\n  return target;\r\n}\r\n\r\n// Remove all comments in a string\r\n// both block and inline comments\r\nexport function stripComments(str: string) {\r\n  return str.replace(/\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*/g, \"\");\r\n}\r\n\r\nexport function stripNewLines(str: string) {\r\n  return str.replace(/\\n/g, \"\");\r\n}\r\n\r\nexport function stripSpaces(str: string) {\r\n  return str.replace(/\\s/g, \"\");\r\n}\r\n\r\nexport function isEmptyFunction(func: Function) {\r\n  const funcName = func.name;\r\n  return stripSpaces(stripNewLines(func.toString())) === `${funcName}(){}`;\r\n}\r\n","import * as THREE from \"three\";\r\nimport {\r\n  defaultCsmDefinitions,\r\n  defaultCsmMainDefinitions,\r\n  defaultFragDefinitions,\r\n  defaultFragMain,\r\n  defaultVertDefinitions,\r\n  defaultVertMain,\r\n} from \"./defaults\";\r\nimport { availabilityMap, defaultPatchMap } from \"./maps\";\r\nimport { requiredPropsMap } from \"./maps/requiredPropsMap\";\r\nimport hash from \"./sdbm\";\r\nimport * as TYPES from \"./types\";\r\nimport {\r\n  deepMergeObjects,\r\n  isConstructor,\r\n  isEmptyFunction,\r\n  stripComments,\r\n} from \"./utils\";\r\n\r\nexport default class CustomShaderMaterial<\r\n  T extends TYPES.MaterialConstructor = typeof THREE.Material\r\n> extends THREE.Material {\r\n  uniforms: TYPES.Uniform = {};\r\n  vertexShader: string = \"\";\r\n  fragmentShader: string = \"\";\r\n\r\n  constructor({\r\n    baseMaterial,\r\n    vertexShader,\r\n    fragmentShader,\r\n    uniforms,\r\n    patchMap,\r\n    cacheKey,\r\n    ...opts\r\n  }: TYPES.CustomShaderMaterialParameters<T>) {\r\n    if (!baseMaterial) {\r\n      throw new Error(\"CustomShaderMaterial: baseMaterial is required.\");\r\n    }\r\n\r\n    let base: THREE.Material;\r\n    if (isConstructor(baseMaterial)) {\r\n      // If base material is a constructor, instantiate it\r\n      // if opts is empty, replace it with undefined\r\n      const isEmptyOpts = Object.keys(opts).length === 0;\r\n      base = new baseMaterial(isEmptyOpts ? undefined : opts);\r\n    } else {\r\n      // Else, use the already created instance as the base material\r\n      // and copy options onto it\r\n      base = baseMaterial;\r\n      Object.assign(base, opts);\r\n    }\r\n\r\n    // Blacklist some materials that are not supported\r\n    const blackList = [\"ShaderMaterial\", \"RawShaderMaterial\"];\r\n    if (blackList.includes(base.type)) {\r\n      throw new Error(\r\n        `CustomShaderMaterial does not support ${base.type} as a base material.`\r\n      );\r\n    }\r\n\r\n    super();\r\n\r\n    // Return a proxy to the base material with CSM types and methods\r\n    const extendedBase = base as typeof base & TYPES.CSMProxy<T>;\r\n    extendedBase.name = `CustomShaderMaterial<${base.name}>`;\r\n    extendedBase.update = this.update.bind(extendedBase);\r\n    extendedBase.__csm = { prevOnBeforeCompile: base.onBeforeCompile };\r\n\r\n    const prevUniforms = extendedBase.uniforms || {};\r\n    const newUniforms = uniforms || {};\r\n    const mergedUniforms = { ...prevUniforms, ...newUniforms };\r\n\r\n    extendedBase.uniforms = this.uniforms = mergedUniforms;\r\n    extendedBase.vertexShader = this.vertexShader = vertexShader || \"\";\r\n    extendedBase.fragmentShader = this.fragmentShader = fragmentShader || \"\";\r\n\r\n    // Initialize custom shaders\r\n    extendedBase.update({\r\n      fragmentShader: extendedBase.fragmentShader,\r\n      vertexShader: extendedBase.vertexShader,\r\n      uniforms: extendedBase.uniforms,\r\n      patchMap,\r\n      cacheKey,\r\n    });\r\n\r\n    return extendedBase;\r\n  }\r\n\r\n  update({\r\n    fragmentShader: _fs,\r\n    vertexShader: _vs,\r\n    uniforms,\r\n    cacheKey,\r\n    patchMap,\r\n  }: Omit<TYPES.CustomShaderMaterialBaseParameters<T>, \"baseMaterial\">) {\r\n    // Strip comments from shaders, makes it so that commented keywords are not detected\r\n    const vertexShader = stripComments(_vs || \"\");\r\n    const fragmentShader = stripComments(_fs || \"\");\r\n\r\n    // Get typed `this` for the proxy\r\n    const self = this as typeof this & TYPES.CSMProxy<T>;\r\n\r\n    // Replace the shaders if they are provided\r\n    if (uniforms) self.uniforms = uniforms;\r\n    if (_vs) self.vertexShader = _vs;\r\n    if (_fs) self.fragmentShader = _fs;\r\n\r\n    // Some keywords require certain properties to be set for their chunks to be included via #ifdef\r\n    // so we must check if the shaders contain these keywords and set the properties accordingly\r\n    Object.entries(requiredPropsMap).forEach(([prop, matchKeywords]) => {\r\n      for (const keyword in matchKeywords) {\r\n        const matchKeyword = matchKeywords[keyword];\r\n        if (\r\n          (fragmentShader && fragmentShader.includes(matchKeyword)) ||\r\n          (vertexShader && vertexShader.includes(matchKeyword))\r\n        ) {\r\n          // @ts-ignore\r\n          if (!self[prop]) {\r\n            // @ts-ignore\r\n            self[prop] = 1;\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    // Check it the previous onBeforeCompile exists\r\n    const prevOnBeforeCompile = self.__csm.prevOnBeforeCompile;\r\n    const doesHavePreviousBeforeCompile = !isEmptyFunction(prevOnBeforeCompile);\r\n\r\n    // Helper function to extend the shader\r\n    const extendShader = (\r\n      prevShader: string,\r\n      newShader?: string,\r\n      isFrag?: boolean\r\n    ) => {\r\n      let mainBody: string | undefined;\r\n      let beforeMain: string = \"\";\r\n\r\n      // Prepare the main body and beforeMain\r\n      if (newShader) {\r\n        const mainBodyRegex =\r\n          /void\\s+main\\s*\\(\\s*\\)[^{]*{((?:[^{}]+|{(?:[^{}]+|{(?:[^{}]+|{(?:[^{}]+|{[^{}]*})*})*})*})*})/gm;\r\n        const mainBodyMatches = newShader.matchAll(mainBodyRegex);\r\n        mainBody = mainBodyMatches.next().value?.[1];\r\n        if (mainBody) mainBody = mainBody.slice(0, -1);\r\n\r\n        const mainIndex = newShader.indexOf(\"void main() {\");\r\n        beforeMain = newShader.slice(0, mainIndex);\r\n      }\r\n\r\n      // Inject\r\n      if (doesHavePreviousBeforeCompile) {\r\n        prevShader = prevShader.replace(\r\n          \"void main() {\",\r\n          `\r\n          // THREE-CustomShaderMaterial by Faraz Shaikh: https://github.com/FarazzShaikh/THREE-CustomShaderMaterial\r\n  \r\n          ${beforeMain}\r\n          \r\n          void main() {\r\n          `\r\n        );\r\n\r\n        const lastMainEndIndex = prevShader.lastIndexOf(\"//~CSM_MAIN_END\");\r\n\r\n        if (lastMainEndIndex !== -1) {\r\n          const toAppend = `\r\n            ${mainBody ? `${mainBody}` : \"\"}\r\n            //~CSM_MAIN_END\r\n          `;\r\n          prevShader =\r\n            prevShader.slice(0, lastMainEndIndex) +\r\n            toAppend +\r\n            prevShader.slice(lastMainEndIndex);\r\n        }\r\n      } else {\r\n        const regex = /void\\s*main\\s*\\(\\s*\\)\\s*{/gm;\r\n\r\n        prevShader = prevShader.replace(\r\n          regex,\r\n          `\r\n          // THREE-CustomShaderMaterial by Faraz Shaikh: https://github.com/FarazzShaikh/THREE-CustomShaderMaterial\r\n  \r\n          ${isFrag ? defaultFragDefinitions : defaultVertDefinitions}\r\n          ${defaultCsmDefinitions}\r\n  \r\n          ${beforeMain}\r\n          \r\n          void main() {\r\n            ${defaultCsmMainDefinitions}\r\n            ${isFrag ? defaultFragMain : defaultVertMain}\r\n\r\n            ${mainBody ? `${mainBody}` : \"\"}\r\n            //~CSM_MAIN_END\r\n          `\r\n        );\r\n      }\r\n\r\n      return prevShader;\r\n    };\r\n\r\n    // Override onBeforeCompile\r\n    self.onBeforeCompile = (\r\n      shader: THREE.WebGLProgramParametersWithUniforms,\r\n      renderer: THREE.WebGLRenderer\r\n    ) => {\r\n      // Apply previous onBeforeCompile\r\n      prevOnBeforeCompile?.(shader, renderer);\r\n\r\n      const userPatchMap = patchMap || {};\r\n      const mergedPatchMap = deepMergeObjects(defaultPatchMap, userPatchMap);\r\n\r\n      // Append some defines\r\n      const type = self.type;\r\n      const typeDefine = type\r\n        ? `#define IS_${type.toUpperCase()};\\n`\r\n        : `#define IS_UNKNOWN;\\n`;\r\n      shader.vertexShader =\r\n        typeDefine + \"#define IS_VERTEX\\n\" + shader.vertexShader;\r\n      shader.fragmentShader =\r\n        typeDefine + \"#define IS_FRAGMENT\\n\" + shader.fragmentShader;\r\n\r\n      // Check if the keyword is available in the current material type\r\n      for (const keyword in mergedPatchMap) {\r\n        const doesIncludeInVert =\r\n          keyword === \"*\" || (vertexShader && vertexShader.includes(keyword));\r\n        const doesIncludeInFrag =\r\n          keyword === \"*\" ||\r\n          (fragmentShader && fragmentShader.includes(keyword));\r\n\r\n        if (doesIncludeInFrag || doesIncludeInVert) {\r\n          const availableIn = availabilityMap[keyword];\r\n\r\n          if (\r\n            availableIn &&\r\n            availableIn !== \"*\" &&\r\n            (Array.isArray(availableIn)\r\n              ? !availableIn.includes(type)\r\n              : availableIn !== type)\r\n          ) {\r\n            console.error(\r\n              `CustomShaderMaterial: ${keyword} is not available in ${type}. Shader cannot compile.`\r\n            );\r\n            return;\r\n          }\r\n\r\n          const patchMap = mergedPatchMap[keyword];\r\n\r\n          for (const toReplace in patchMap) {\r\n            const replaceWith = patchMap[toReplace];\r\n            if (typeof replaceWith === \"object\") {\r\n              const type = replaceWith.type;\r\n              const value = replaceWith.value;\r\n\r\n              if (type === \"fs\") {\r\n                shader.fragmentShader = shader.fragmentShader.replace(\r\n                  toReplace,\r\n                  value\r\n                );\r\n              } else if (type === \"vs\") {\r\n                shader.vertexShader = shader.vertexShader.replace(\r\n                  toReplace,\r\n                  value\r\n                );\r\n              }\r\n            } else if (replaceWith) {\r\n              shader.vertexShader = shader.vertexShader.replace(\r\n                toReplace,\r\n                replaceWith\r\n              );\r\n              shader.fragmentShader = shader.fragmentShader.replace(\r\n                toReplace,\r\n                replaceWith\r\n              );\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Extend the shaders\r\n      shader.vertexShader = extendShader(\r\n        shader.vertexShader,\r\n        vertexShader,\r\n        false\r\n      );\r\n\r\n      shader.fragmentShader = extendShader(\r\n        shader.fragmentShader,\r\n        fragmentShader,\r\n        true\r\n      );\r\n\r\n      if (uniforms) {\r\n        shader.uniforms = { ...shader.uniforms, ...self.uniforms };\r\n      }\r\n\r\n      self.uniforms = shader.uniforms;\r\n    };\r\n\r\n    const prevCacheKey = self.customProgramCacheKey;\r\n\r\n    self.customProgramCacheKey = () => {\r\n      return (\r\n        (cacheKey?.() || hash((vertexShader || \"\") + (fragmentShader || \"\"))) +\r\n        prevCacheKey?.call(self)\r\n      );\r\n    };\r\n\r\n    self.needsUpdate = true;\r\n  }\r\n}\r\n\r\nexport {\r\n  type CSMPatchMap,\r\n  type CSMProxy,\r\n  type CustomShaderMaterialParameters,\r\n  type MaterialConstructor,\r\n} from \"./types\";\r\n"],"names":["defaultCsmDefinitions","defaultCsmMainDefinitions","defaultVertDefinitions","defaultVertMain","defaultFragDefinitions","defaultFragMain","keywordMap","availabilityMap","defaultPatchMap","THREE","requiredPropsMap","sdbm","string","hash","i","h","isConstructor","f","err","deepMergeObjects","target","source","key","stripComments","str","stripNewLines","stripSpaces","isEmptyFunction","func","funcName","CustomShaderMaterial","baseMaterial","vertexShader","fragmentShader","uniforms","patchMap","cacheKey","opts","base","isEmptyOpts","extendedBase","mergedUniforms","_fs","_vs","self","prop","matchKeywords","keyword","matchKeyword","prevOnBeforeCompile","doesHavePreviousBeforeCompile","extendShader","prevShader","newShader","isFrag","mainBody","beforeMain","mainBodyRegex","_a","mainIndex","lastMainEndIndex","toAppend","regex","shader","renderer","mergedPatchMap","type","typeDefine","doesIncludeInVert","availableIn","toReplace","replaceWith","value","prevCacheKey"],"mappings":"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"}